/*
 * Copyright (C) Jonathan D. Belanger 2017.
 * All Rights Reserved.
 *
 * This software is furnished under a license and may be used and copied only
 * in accordance with the terms of such license and with the inclusion of the
 * above copyright notice.  This software or any other copies thereof may not
 * be provided or otherwise made available to any other person.  No title to
 * and ownership of the software is hereby transferred.
 *
 * The information in this software is subject to change without notice and
 * should not be construed as a commitment by the author or co-authors.
 *
 * The author and any co-authors assume no responsibility for the use or
 * reliability of this software.
 *
 * Description:
 *
 *  This source file contains the functions needed to implement the
 *  Probe Queue (PQ) functionality of the Cbox.
 *
 * Revision History:
 *
 *  V01.000 29-Dec-2017 Jonathan D. Belanger
 *  Initially written.
 */
#include "CPU/Cbox/AXP_21264_Cbox.h"
#include "CommonUtilities/AXP_Configure.h"
#include "CPU/Cbox/SystemInterface/AXP_21264_21274_Common.h"
#include "CPU/Caches/AXP_21264_CacheDefs.h"
#include "CPU/Mbox/AXP_21264_Mbox.h"
#include "CPU/Ebox/AXP_21264_Ebox.h"
#include "CPU/Fbox/AXP_21264_Fbox.h"
#include "CPU/Ibox/AXP_21264_Ibox.h"
#include "CPU/Cbox/SystemInterface/AXP_21264_to_System.h"

/*
 * AXP_21264_OldestPQFlags
 *  This function is called to determine what the settings for the M1, M@, and
 *  CH flags should be as part of a response to the oldest pending Probe from
 *  the system.
 *
 * Input Parameters:
 *  cpu:
 *      A pointer to the CPU structure where the Bcache is stored.
 *  m1:
 *      A pointer to receive a boolean value indicating if this was a simple
 *      cache miss.
 *  m2:
 *      A pointer to receive a boolean value indicating if this was a more
 *      complex cache miss (used in association with the value returned in the
 *      ch parameter).
 *  ch:
 *      A pointer to receive a boolean value indicating that a cache hit
 *      occurred.
 *
 * Output Parameters:
 *  None.
 *
 * Return Values:
 *  None.
 */
void AXP_21264_OldestPQFlags(AXP_21264_CPU *cpu, bool *m1, bool *m2, bool *ch)
{
    AXP_21264_CBOX_PQ *pq = NULL;
    int ii, entry;
    int end, start1, end1, start2 = -1, end2;

    if (cpu->pqTop > cpu->pqBottom)
    {
        start1 = cpu->pqTop;
        end1 = AXP_21264_PQ_LEN - 1;
        start2 = 0;
        end2 = cpu->pqBottom;
    }
    else
    {
        start1 = cpu->pqTop;
        end1 = cpu->pqBottom;
    }

    /*
     * Search through the list to find the first entry that can be processed.
     */
    ii = start1;
    end = end1;
    while ((ii <= end) && (pq == NULL ))
    {
        if ((cpu->pq[ii].valid == true) && (cpu->pq[ii].pendingRsp == false)
            && (cpu->pq[ii].processed == true))
        {
            pq = &cpu->pq[ii];
            entry = ii;
        }
        if ((pq == NULL ) && (start2 != -1) && (ii == end))
        {
            ii = start2;
            end = end2;
            start2 = -1;
        }
        else
        {
            ii++;
        }
    }

    /*
     * First things first, set the value of the flags to all false.
     */
    *m1 = false;
    *m2 = false;
    *ch = false;

    /*
     * HRM Table 4-12, 21264-to-System Command Fields Definitions
     *
     * SysAddOut    Definition
     * ---------    -------------------------------------------------------
     * M1           When set, reports a miss to the system for the oldest
     *              probe.  When clear, has no meaning.
     * M2           When set, reports that the oldest probe has missed in
     *              cache. Also, this bit is set for system-to-21264 probe
     *              commands that hit but have no data movement (see the CH
     *              bit, below).  When clear, has no meaning.
     *              M1 and M2 are not asserted simultaneously. Reporting
     *              probe results as soon as possible is critical to
     *              high-speed operation, so when a result is known the
     *              21264 uses the earliest opportunity to send an M signal
     *              to the system. M bit assertion can occur either in a
     *              valid command or a NZNOP.
     * CH           The cache hit bit is asserted, along with M2, when
     *              probes with no data movement hit in the Dcache or
     *              Bcache. This response can be generated by a probe that
     *              explicitly indicates no data movement or a ReadIfDirty
     *              command that hits on a valid but clean or shared block.
     */
    if (pq != NULL)
    {
        AXP_VA physAddr = {.va = pq->pa};
        u32 status = AXP_21264_CACHE_MISS;
        u32 ctagIndex = physAddr.vaIdxInfo.index;
        u32 setToUse = 0;

        /*
         * We use the CTAG to determine Dcache bits because the CTAG is a
         * duplicate of the DTAG, except that it is physically indexed and
         * tagged.  Lock the Cbox IPR mutex first.
         */
        pthread_mutex_lock(&cpu->cBoxIPRMutex);

        /*
         * If set 0 at the CTAG index is not valid or the tags don't match,
         * then try set 1.
         */
        if ((cpu->ctag[ctagIndex][setToUse].valid == false) ||
            (cpu->ctag[ctagIndex][setToUse].physTag != physAddr.vaIdxInfo.tag))
        {
            setToUse++;
        }

        /*
         * If set 1 at the CTAG index is not valid or the tags don't match,
         * then set the set to use to 2 (one past the highest valid value).
         */
        if ((cpu->ctag[ctagIndex][setToUse].valid == false) ||
            (cpu->ctag[ctagIndex][setToUse].physTag != physAddr.vaIdxInfo.tag))
        {
            setToUse++;
        }

        /*
         * If we found something, check the bits out for the Dcache line and
         * set the status bits as appropriate.
         */
        if (setToUse < AXP_2_WAY_CACHE)
        {
            status = AXP_21264_CACHE_HIT;
            if (cpu->ctag[ctagIndex][setToUse].dirty == true)
            {
                status |= AXP_21264_CACHE_DIRTY;
            }
            if (cpu->ctag[ctagIndex][setToUse].shared == true)
            {
                status |= AXP_21264_CACHE_SHARED;
            }
        }

        /*
         * Unlock the Cbox IPR mutex.  We are all done with the CTAG.
         */
        pthread_mutex_unlock(&cpu->cBoxIPRMutex);

        /*
         * If the Dcache got us a MISS, then check the Bcache (which is a
         * superset of the combination of Dcache and Icache).  We need to check
         * both, even though the Bcache is supposed to be a superset, because
         * there may have been an update to the Dcache that has not made it to
         * the Bcache.
         */
        if (AXP_CACHE_MISS(status) == true)
        {
            status = AXP_21264_Bcache_Status(cpu, pq->pa);
        }

        /*
         * If we still have a MISS, then set the M1 bit.
         */
        if (AXP_CACHE_MISS(status) == true)
        {
            *m1 = true;
        }

        /*
         * If we have a HIT, but the probe was not looking to move data, then
         * set set the CH bit, and conditionally the M2 bit.
         */
        else if (pq->probe != 0)
        {
            *ch = true;

            /*
             * If the probe was for a ReadIfDirty, and the cache entry is either
             * clean or shared, then set the M2 bit.
             */
            if ((AXP_21264_GET_PROBE_DM(pq->probe) == AXP_21264_DM_RDDIRTY) &&
                ((AXP_CACHE_CLEAN(status) == true) ||
                 (AXP_CACHE_CLEAN_SHARED(status) == true) ||
                 (AXP_CACHE_DIRTY_SHARED(status) == true)))
            {
                *m2 = true;
            }
        }
        if ((*m1 == true) || (*m2 == true) || (*ch == true))
        {
            AXP_21264_Free_PQ(cpu, entry);
        }
    }

    /*
     * Return back to the caller.
     */
    return;
}

/*
 * AXP_21264_PQ_Empty
 *  This function is called to determine of there is a record in the Probe
 *  Queue (PQ) that needs to be processed.
 *
 * Input Parameters:
 *   cpu:
 *      A pointer to the CPU structure for the emulated Alpha AXP 21264
 *      processor.
 *
 * Output Parameters:
 *  None.
 *
 * Return Values:
 *  -1:     No entries requiring processing.
 *  >=0:    Index of next entry that can be processed.
 */
int AXP_21264_PQ_Empty(AXP_21264_CPU *cpu)
{
    int retVal = -1;
    int ii;
    int end, start1, end1, start2 = -1, end2;

    if (cpu->pqTop > cpu->pqBottom)
    {
        start1 = cpu->pqTop;
        end1 = AXP_21264_PQ_LEN - 1;
        start2 = 0;
        end2 = cpu->pqBottom;
    }
    else
    {
        start1 = cpu->pqTop;
        end1 = cpu->pqBottom;
    }

    /*
     * Search through the list to find the first entry that can be processed.
     */
    ii = start1;
    end = end1;
    while ((ii <= end) && (retVal == -1))
    {
        if ((cpu->pq[ii].valid == true) && (cpu->pq[ii].processed == false))
        {
            retVal = ii;
        }
        if ((retVal == -1) && (start2 != -1) && (ii == end))
        {
            ii = start2;
            end = end2;
            start2 = -1;
        }
        else
        {
            ii++;
        }
    }

    /*
     * Return what we found, if anything.
     */
    return (retVal);
}

/*
 * AXP_21264_Process_PQ
 *  This function is called to check the first unprocessed entry on the queue
 *  containing the PQ records.
 *
 * Input Parameters:
 *   cpu:
 *      A pointer to the CPU structure for the emulated Alpha AXP 21264
 *      processor.
 *  entry:
 *      An integer value that is the entry in the PQ to be processed.
 *
 * Output Parameters:
 *  None.
 *
 * Return Values:
 *  None.
 */
void AXP_21264_Process_PQ(AXP_21264_CPU *cpu, int entry)
{
    AXP_21264_CBOX_PQ *pq = &cpu->pq[entry];
    AXP_ProbeStatus probeStatus;
    AXP_VA physAddr = {.va = pq->pa};
    u32 ctagIndex = physAddr.vaIdxInfo.index;
    u32 setToUse;
    u32 dCacheStatus = AXP_21264_CACHE_MISS;
    u32 bCacheStatus;
    u8 vdb = 0;
    u8 maf = 0;
    bool dm = false;
    bool vs = false;
    bool ms = false;
    bool miss = false;

    /*
     * Between the time when a probe request was queued up and this queue
     * entry was considered for processing, it may have already been processed.
     * If so, there is no need to process it again.
     */
    pthread_mutex_lock(&cpu->cBoxIPRMutex);
    if ((pq->valid == true) && (pq->processed == false))
    {
        pthread_mutex_lock(&cpu->bCacheMutex);
        if ((cpu->ctag[ctagIndex][0].valid = true) &&
            (cpu->ctag[ctagIndex][0].physTag == physAddr.vaIdxInfo.tag))
        {
            setToUse = 0;
            dCacheStatus = AXP_21264_CACHE_HIT;
        }
        else if ((cpu->ctag[ctagIndex][1].valid = true) &&
                 (cpu->dtag[ctagIndex][1].physTag == physAddr.vaIdxInfo.tag))
        {
            setToUse = 1;
            dCacheStatus = AXP_21264_CACHE_HIT;
        }

        /*
         * HRM 4.7.7.2 Data Transfer Commands, page 4-28
         *
         * Probe commands can combine a SysDc command along with MBDone.  In
         * that event, the probe is considered ahead of the SysDc command.  If
         * the SysDc command allows the 21264 to retire an instruction before
         * am MB, or allows the 21264 itself to retire an MB (sysDc is MBDone),
         * that MB will not complete until the probe is executed.
         */
        if (pq->probe != 0)
        {
            AXP_21264_CBOX_CTAG *ctag = &cpu->ctag[ctagIndex][setToUse];
            AXP_DTAG_BLK *dtag;
            u32 dCacheIdx = ctag->dtagIndex;

            /*
             * Get the remaining status bits of the Dcache.  We don't call the
             * Mbox equivalent of these because we are just looking at the CTAG
             * array.
             */
            if (dCacheStatus == AXP_21264_CACHE_HIT)
            {
                if (ctag->dirty == true)
                {
                    dCacheStatus |= AXP_21264_CACHE_DIRTY;
                }
                if (ctag->shared == true)
                {
                    dCacheStatus |= AXP_21264_CACHE_SHARED;
                }
            }
            bCacheStatus = AXP_21264_Bcache_Status(cpu, pq->pa);

            if ((AXP_CACHE_CLEAN(dCacheStatus) == true) ||
                (AXP_CACHE_CLEAN(bCacheStatus) == true))
            {
                probeStatus = HitClean;
            }
            else if ((AXP_CACHE_CLEAN_SHARED(dCacheStatus) == true) ||
                     (AXP_CACHE_CLEAN_SHARED(bCacheStatus) == true))
            {
                probeStatus = HitShared;
            }
            else if ((AXP_CACHE_DIRTY(dCacheStatus) == true) ||
                     (AXP_CACHE_DIRTY(bCacheStatus) == true))
            {
                probeStatus = HitDirty;
            }
            else if ((AXP_CACHE_DIRTY_SHARED(dCacheStatus) == true) ||
                     (AXP_CACHE_DIRTY_SHARED(bCacheStatus) == true))
            {
                probeStatus = HitSharedDirty;
            }
            else
            {
                miss = true;
            }

            switch (AXP_21264_GET_PROBE_DM(pq->probe))
            {
                case AXP_21264_DM_NOP:
                    /* Nothing to do here. */
                    break;

                case AXP_21264_DM_RDHIT:
                    if ((AXP_CACHE_HIT(dCacheStatus) == true) ||
                        (AXP_CACHE_HIT(bCacheStatus) == true))
                    {
                        dm = true;
                    }
                    break;

                case AXP_21264_DM_RDDIRTY:
                    if ((AXP_CACHE_DIRTY(dCacheStatus) == true) ||
                        (AXP_CACHE_DIRTY(bCacheStatus) == true))
                    {
                        dm = true;
                    }
                    break;

                case AXP_21264_DM_RDANY:
                    dm = true; /* return whatever is in the block */
                    break;
            }

            /*
             * If we have data movement, then let's go get the block to be sent
             * to the system towards after processing the probe.
             */
            if (dm == true)
            {
                if (AXP_CACHE_HIT(dCacheStatus) == true)
                {
                    pthread_mutex_lock(&cpu->dCacheMutex);
                    vdb = AXP_21264_Add_VDB(cpu,
                                            probeResponse,
                                            pq->pa,
                                            cpu->dCache[dCacheIdx][setToUse].data,
                                            false,
                                            false);
                    pthread_mutex_unlock(&cpu->dCacheMutex);
                }
                else
                {
                    u32 index = AXP_21264_Bcache_Index(cpu, pq->pa);

                    /*
                     * Copy the data.
                     */
                    vdb = AXP_21264_Add_VDB(cpu,
                                            probeResponse,
                                            pq->pa,
                                            cpu->bCache[index],
                                            false,
                                            false);
                }
                vs = true;
            }
            ms = AXP_21265_Check_MAFAddrSent(cpu, pq->pa, &maf);

            /*
             * Misses are not reported through a probe response.
             */
            if (miss == false)
            {
                if (cpu->noProbeResponses == false)
                {
                    cpu->noProbeResponses = AXP_21264_IsSetP_VDB(cpu, pq->pa);
                }
                if (cpu->noProbeResponses == false)
                {
                    AXP_21264_SYSBUS_System sys;

                    /*
                     * TODO:    This code is completely bogus.  It is only here
                     *          to keep the compiler happy.  Cache coherence is
                     *          to be vastly changed.  There will be no need
                     *          for Probes and Prober Responses through the
                     *          system.  The Bcaches are going to maintain
                     *          coherence automatically.
                     */
                    sys.cmd = ProbeResponse;
                    sys.ch = vs;
                    sys.rv = vs || dm || ms;
                    sys.id = vdb;
                    sys.mask = maf;
                    if (probeStatus == HitSharedDirty)
                    {
                        AXP_21264_SendToSystem(cpu, &sys);
                    }
                }
                else
                {
                    pq->dm = dm;
                    pq->vs = vs;
                    pq->vdb = vdb;
                    pq->ms = ms;
                    pq->maf = maf;
                    pq->probeStatus = probeStatus;
                    pq->pendingRsp = true;
                }
            }

            pthread_mutex_lock(&cpu->dtagMutex);
            dtag = &cpu->dtag[dCacheIdx][setToUse];
            switch (AXP_21264_GET_PROBE_NS(pq->probe))
            {
                case AXP_21264_NS_NOP:
                case AXP_21264_NS_RES:
                    /* Nothing to do here. */
                    break;

                case AXP_21264_NS_CLEAN:

                    /*
                     * First, Dcache.
                     */
                    if (AXP_CACHE_HIT(dCacheStatus) == true)
                    {
                        dtag->dirty = ctag->dirty = false;
                        dtag->shared = ctag->shared = false;
                    }

                    /*
                     * Finally, Bcache.
                     */
                    if (AXP_CACHE_HIT(bCacheStatus) == true)
                    {
                        AXP_21264_Bcache_ClearDirty(cpu, pq->pa);
                        AXP_21264_Bcache_ClearShared(cpu, pq->pa);
                    }
                    break;

                case AXP_21264_NS_CLEAN_SHARED:

                    /*
                     * First, Dcache.
                     */
                    if (AXP_CACHE_HIT(dCacheStatus) == true)
                    {
                        dtag->dirty = ctag->dirty = false;
                        dtag->shared = ctag->shared = true;
                    }

                    /*
                     * Finally, Bcache.
                     */
                    if (AXP_CACHE_HIT(bCacheStatus) == true)
                    {
                        AXP_21264_Bcache_ClearDirty(cpu, pq->pa);
                        AXP_21264_Bcache_SetShared(cpu, pq->pa);
                    }
                    break;

                case AXP_21264_NS_TRANS3:

                    /*
                     * First, Dcache:
                     *
                     * Clean  ==> Clean/Shared
                     * Dirty/Shared ==> Clean/Shared
                     */
                    if ((AXP_CACHE_CLEAN(dCacheStatus) == true) ||
                        (AXP_CACHE_DIRTY_SHARED(dCacheStatus) == true))
                    {
                        dtag->shared = ctag->shared = true;
                        dtag->dirty = ctag->dirty = false;
                    }

                    /*
                     * Dirty ==> Invalid
                     */
                    else if (AXP_CACHE_DIRTY(dCacheStatus) == true)
                    {
                        dtag->valid = ctag->valid = false;
                    }

                    /*
                     * Finally, Bcache:
                     *
                     * Clean  ==> Clean/Shared
                     * Dirty/Shared ==> Clean/Shared
                     */
                    if ((AXP_CACHE_CLEAN(bCacheStatus) == true) ||
                        (AXP_CACHE_DIRTY_SHARED(bCacheStatus) == true))
                    {
                        AXP_21264_Bcache_SetShared(cpu, pq->pa);
                        AXP_21264_Bcache_ClearDirty(cpu, pq->pa);
                    }

                    /*
                     * Dirty ==> Invalid
                     */
                    else if (AXP_CACHE_DIRTY(bCacheStatus) == true)
                    {
                        AXP_21264_Bcache_Evict(cpu, pq->pa);
                    }
                    break;

                case AXP_21264_NS_DIRTY_SHARED:

                    /*
                     * First, Dcache.
                     */
                    if (AXP_CACHE_HIT(dCacheStatus) == true)
                    {
                        dtag->dirty = ctag->dirty = true;
                        dtag->shared = ctag->shared = true;
                    }

                    /*
                     * Finally, Bcache.
                     */
                    if (AXP_CACHE_HIT(bCacheStatus) == true)
                    {
                        AXP_21264_Bcache_SetDirty(cpu, pq->pa);
                        AXP_21264_Bcache_SetShared(cpu, pq->pa);
                    }
                    break;

                case AXP_21264_NS_INVALID:

                    /*
                     * First, Dcache.
                     */
                    if (AXP_CACHE_HIT(dCacheStatus) == true)
                    {
                        dtag->valid = ctag->valid = false;
                    }

                    /*
                     * Finally, Bcache.
                     */
                    if (AXP_CACHE_HIT(bCacheStatus) == true)
                    {
                        AXP_21264_Bcache_Evict(cpu, pq->pa);
                    }
                    break;

                case AXP_21264_NS_TRANS1:

                    /*
                     * First, Dcache:
                     *
                     * Clean ==> Clean/Shared
                     * Dirty ==> Dirty/Shared
                     */
                    if ((AXP_CACHE_CLEAN(dCacheStatus) == true) ||
                        (AXP_CACHE_DIRTY(dCacheStatus) == true))
                    {
                        dtag->shared = ctag->shared = true;
                    }

                    /*
                     * Finally, Bcache.
                     *
                     * Clean ==> Clean/Shared
                     * Dirty ==> Dirty/Shared
                     */
                    if ((AXP_CACHE_CLEAN(bCacheStatus) == true) ||
                        (AXP_CACHE_DIRTY(bCacheStatus) == true))
                    {
                        AXP_21264_Bcache_SetShared(cpu, pq->pa);
                    }
                    break;
            }
            pthread_mutex_unlock(&cpu->dtagMutex);
        }

        /*
         * Process the SysDc section of the request.
         */
        switch (pq->sysDc)
        {
            case SysDC_Nop:
                break;

            case ReleaseBuffer:
            case WriteData:
                if (pq->rpb == true)
                {
                    AXP_21264_ClearP_VDB(cpu, pq->ID);
                }
                if (pq->rvb == true)
                {
                    if (AXP_21264_IOWB_ID(pq->ID) == true)
                    {
                        AXP_21264_Free_IOWB(cpu, AXP_MASK_ID(pq->ID));
                    }
                    else
                    {
                        AXP_21264_Free_VDB(cpu, pq->ID);
                    }
                }
                break;

                /*
                 * All the following will finally be processed by the appropriate
                 * completion code.  The first set have some specific processing,
                 * but should fall through like the others.
                 *
                 * HRM: 4.5.3 Cache Block State Transitions
                 *
                 * The cache state transitions caused by 21264-generated commands
                 * are under the full control of the system environment using the
                 * SysDc (system data control) commands.  Table 4–4 lists these
                 * commands.
                 *
                 * Table 4–4 System Responses to 21264 Commands
                 * --------------------------   -----------------------------------
                 * Response Type                21264 Action
                 * --------------------------   -----------------------------------
                 * SysDc ReadData               Fill block with the associated data
                 *                              and update tag with clean cache
                 *                              status.
                 * SysDc ReadDataDirty          Fill block with the associated data
                 *                              and update tag with dirty cache
                 *                              status.
                 * SysDc ReadDataShared         Fill block with the associated data
                 *                              and update tag with shared cache
                 *                              status.
                 * SysDc ReadDataShared/Dirty   Fill block with the associated data
                 *                              and update tag with dirty/shared
                 *                              status.
                 * SysDc ReadDataError          Fill block with all-ones reference
                 *                              pattern and update tag with invalid
                 *                              status.
                 * SysDc ChangeToDirtySuccess   Unconditionally update block with
                 *                              dirty cache status.
                 * SysDc ChangeToDirtyFail      Do not update cache status and fail
                 *                              any associated STx_C instructions.
                 * --------------------------   -----------------------------------
                 *
                 * Table 4–5 System Responses to 21264 Commands and Reactions
                 *
                 * 21264 CMD    SysDc                   21264 Action
                 * ---------    ---------------------   ---------------------------
                 * Rdx          ReadData                This is a normal fill. The
                 *              ReadDataShared          cache block is filled and
                 *                                      marked clean or shared
                 *                                      based on SysDc.
                 * Rdx          ReadDataShared/         The cache block is filled
                 *              ReadDataShared          and marked dirty/shared.
                 *                                      Succeeding store commands
                 *                                      cannot update the block
                 *                                      without external reference.
                 * Rdx          ReadDataDirty           The cache block is filled
                 *                                      and marked dirty.
                 * Rdx          ReadDataError           The cache block access was
                 *                                      to NXM address space. The
                 *                                      21264 delivers an all-ones
                 *                                      pattern to any load command
                 *                                      and evicts the block from
                 *                                      the cache (with associated
                 *                                      victim processing). The
                 *                                      cache block is marked
                 *                                      invalid.
                 * Rdx          ChangeToDirtySuccess    Both SysDc responses are
                 *              ChangeToDirtyFail       illegal for read commands.
                 * RdBlkModx    ReadData                The cache block is filled
                 *              ReadDataShared          and marked with a
                 *              ReadDataShared/Dirty    non-writable status. If the
                 *                                      store instruction that
                 *                                      generated the RdBlkModx
                 *                                      command is still active
                 *                                      (not killed), the 21264
                 *                                      will retry the instruction,
                 *                                      generating the appropriate
                 *                                      ChangeToDirty command.
                 *                                      Succeeding store commands
                 *                                      cannot update the block
                 *                                      without external reference.
                 * RdBlkModx    ReadDataDirty           The 21264 performs a normal
                 *                                      fill response, and the
                 *                                      cache block becomes
                 *                                      writable.
                 * RdBlkModx    ChangeToDirtySuccess    Both SysDc responses are
                 *              ChangeToDirtyFail       illegal for read/modify
                 *                                      commands.
                 * RdBlkModx    ReadDataError           The cache block command was
                 *                                      to NXM address space. The
                 *                                      21264 delivers an all-ones
                 *                                      pattern to any dependent
                 *                                      load command, forces a fail
                 *                                      action on any pending store
                 *                                      commands to this block, and
                 *                                      any store to this block is
                 *                                      not retried. The Cbox
                 *                                      evicts the cache block from
                 *                                      the cache system (with
                 *                                      associated victim
                 *                                      processing). The cache
                 *                                      block is marked invalid.
                 * ChxToDirty   ReadData                The original data in the
                 *              ReadDataShared          Dcache is replaced with the
                 *              ReadDataShared/Dirty    filled data. The block is
                 *                                      not writable, so the 21264
                 *                                      will retry the store
                 *                                      instruction and generate
                 *                                      another ChxToDirty class
                 *                                      command. To avoid a
                 *                                      potential livelock
                 *                                      situation, the
                 *                                      STC_ENABLE CSR bit must be
                 *                                      set.  Any STx_C instruction
                 *                                      to this block is forced to
                 *                                      fail. In addition, a
                 *                                      Shared/Dirty response
                 *                                      causes the 21264 to
                 *                                      generate a victim for this
                 *                                      block upon eviction.
                 * ChxToDirty   ReadDataDirty           The data in the Dcache is
                 *                                      replaced with the filled
                 *                                      data.  The block is
                 *                                      writable, so the store
                 *                                      instruction that generated
                 *                                      the original command can
                 *                                      update this block. Any
                 *                                      STx_C instruction to this
                 *                                      block is forced to fail. In
                 *                                      addition, the 21264
                 *                                      generates a victim for this
                 *                                      block upon eviction.
                 * ChxToDirty   ReadDataError           Impossible situation. The
                 *                                      block must be cached to
                 *                                      generate a ChxToDirty
                 *                                      command. Caching the block
                 *                                      is not possible because all
                 *                                      NXM fills are filled
                 *                                      non-cached.
                 * ChToDirty    ChangeToDirtySuccess    Normal response.
                 *                                      ChangeToDirtySuccess makes
                 *                                      the block writable.  The
                 *                                      21264 retries the store
                 *                                      instruction and updates the
                 *                                      Dcache. Any STx_C
                 *                                      instruction associated with
                 *                                      this block is allowed to
                 *                                      succeed.
                 * ChxToDirty   ChangeToDirtyFail       The MAF entry is retired.
                 *                                      Any STx_C instruction
                 *                                      associated with the block
                 *                                      is forced to fail. If a STx
                 *                                      instruction generated this
                 *                                      block, the 21264 retries
                 *                                      and generates either a
                 *                                      RdBlkModx (because the
                 *                                      reference that failed the
                 *                                      ChangeToDirty also
                 *                                      invalidated the cache by
                 *                                      way of an invalidating
                 *                                      probe) or another
                 *                                      ChxToDirty command.
                 * InvalToDirty ReadData                The block is not writable,
                 *              ReadDataShared          so the 21264 will retry the
                 *              ReadDataShared/Dirty    WH64 instruction and
                 *                                      generate a ChxToDirty
                 *                                      command.
                 * InvalToDirty ReadDataError           The 21264 doesn’t send
                 *                                      InvalToDirty commands
                 *                                      off-chip speculatively.
                 *                                      This NXM condition is a
                 *                                      hard error. Systems should
                 *                                      perform a machine check.
                 * InvalToDirty ReadDataDirty           The block is writable.
                 *              ChangeToDirtySuccess    Done.
                 * InvalToDirty ChangeToDirtyFail       Illegal.  InvalToDirty
                 *                                      instructions must provide a
                 *                                      cache block.
                 * Fetchx       ReadData                The 21264 delivers the data
                 * Rdiox        ReadDataShared          block, independent of its
                 *              ReadDataShared/Dirty    status, to waiting load
                 *              ReadDataDirty           instructions and does not
                 *                                      cache the block in the
                 *                                      21264 cache system.
                 * Fetchx       ReadDataError           The cache block address was
                 *                                      to an NXM address space.
                 *                                      The 21264 delivers the
                 *                                      all-ones patterns to any
                 *                                      dependent load instructions
                 *                                      and does not cache the
                 *                                      block in the 21264 cache
                 *                                      system.
                 * Rdiox        ReadDataError           The cache block access was
                 *                                      to NXM address space. The
                 *                                      21264 delivers an all-ones
                 *                                      pattern to any load command
                 *                                      and does not cache the
                 *                                      block in the 21264 cache
                 *                                      system.
                 * Evict        ChangeToDirtyFail       Retiring the MAF entry is
                 *                                      the only legal response.
                 * STCChangeTo  ReadDataX               All fill and
                 * Dirty        ChangeToDirtyFail       ChangeToDirtyFail responses
                 *                                      will fail the STx_C
                 *                                      requirements.
                 * STCChangeTo  ChangeToDirtySuccess    The STx_C instruction
                 * Dirty                                succeeds.
                 * MB           MBDone                  Acknowledgment for MB.
                 * ----------------------------------------------------------------
                 * Rdx              = Generated by Load or Istream references
                 * RdBlkModx        = Generated by store references
                 * ChxToDirty       = Generated by store references that hit in the
                 *                    cache system.  These include: CleanToDirty,
                 *                    SharedToDirty, and STCChangeToDirty commands.
                 * InvalToDirty     = Generated by WH64 instructions that miss in the
                 *                    cache system.
                 * FetchBlk*        = Non-cached references to memory space that have
                 *                    missed in the cache system.
                 * Rdiox            = Non-cached references to I/O space.
                 * Evict            = Generated by the ECB instruction.
                 * STCChangeToDirty = Generated by the STx_C instructions.
                 */
            case ReadDataError:
            case ChangeToDirtySuccess:
            case ChangeToDirtyFail:
            case MBDone:
                AXP_21264_Complete_MAF(cpu,
                                       pq->ID,
                                       pq->sysDc,
                                       (u8 *) pq->sysData);
                break;

            case ReadData:
                AXP_21264_Complete_MAF(cpu,
                                       pq->ID,
                                       ReadData,
                                       (u8 *) pq->sysData);
                break;

            case ReadDataDirty:
                AXP_21264_Complete_MAF(cpu,
                                       pq->ID,
                                       ReadDataDirty,
                                       (u8 *) pq->sysData);
                break;

            case ReadDataShared:
                AXP_21264_Complete_MAF(cpu,
                                       pq->ID,
                                       ReadDataShared,
                                       (u8 *) pq->sysData);
                break;

            case ReadDataSharedDirty:
                AXP_21264_Complete_MAF(cpu,
                                       pq->ID,
                                       ReadDataSharedDirty,
                                       (u8 *) pq->sysData);
                break;
        }
        pthread_mutex_lock(&cpu->bCacheMutex);

        /*
         * Indicate that the entry is now processed, and unlock the Cbox IPR
         * lock, if it is still locked.
         */
        pq->processed = true;

        /*
         * A miss will need to be sent on a non-ProbeResponse command, and if
         * this PQ entry still has a ProbeResponse pending, then we cannot free
         * the PQ entry, yet.
         */
        if ((miss == false) && (pq->pendingRsp == false))
        {
            AXP_21264_Free_PQ(cpu, entry);
        }
    }
    pthread_mutex_unlock(&cpu->cBoxIPRMutex);

    /*
     * Return back to the caller.
     */
    return;
}

/*
 * AXP_21264_SendRsps_PQ
 *  This P-bit was cleared in a VDB.  Send out any pending ProbeResponses and
 *  then free up the PQ entries.
 *
 * Input Parameters:
 *   cpu:
 *      A pointer to the CPU structure for the emulated Alpha AXP 21264
 *      processor.
 *
 * Output Parameters:
 *  None.
 *
 * Return Values:
 *  None.
 *
 */
void AXP_21264_SendRsps_PQ(AXP_21264_CPU *cpu)
{
    int ii;
    int end, start1, end1, start2 = -1, end2;

    if (cpu->pqTop > cpu->pqBottom)
    {
        start1 = cpu->pqTop;
        end1 = AXP_21264_PQ_LEN - 1;
        start2 = 0;
        end2 = cpu->pqBottom;
    }
    else
    {
        start1 = cpu->pqTop;
        end1 = cpu->pqBottom;
    }

    /*
     * Search through the list to find the first entry that can be processed.
     */
    ii = start1;
    end = end1;
    while (ii <= end)
    {
        if ((cpu->pq[ii].valid == true) &&
            (cpu->pq[ii].processed == true) &&
            (cpu->pq[ii].pendingRsp == true))
        {
            /*        AXP_System_ProbeResponse(
             cpu->pq[ii].dm,
             cpu->pq[ii].vs,
             cpu->pq[ii].vdb,
             cpu->pq[ii].ms,
             cpu->pq[ii].maf,
             cpu->pq[ii].probeStatus);
             */cpu->pq[ii].pendingRsp = true;
            AXP_21264_Free_PQ(cpu, ii);
        }
        if ((start2 != -1) && (ii == end))
        {
            ii = start2;
            end = end2;
            start2 = -1;
        }
        else
        {
            ii++;
        }
    }

    /*
     * Return back to the caller.
     */
    return;
}

/*
 * AXP_21264_Add_PQ
 *  This function is called to add an entry into the Probe Queue (PQ).
 *
 *  NOTE:   The system calls this function.  It does so when probing the Cbox
 *          about information within the CPU's caches.  It also is used to send
 *          requested data to the CPU from the System.  The following values of
 *          sysDc will supply sysData from the system:
 *              ReadDataError
 *              ReadData
 *              ReadDataDirty
 *              ReadDataShared
 *              ReadDataSharedDirty
 *
 * Input Parameters:
 *  cpu:
 *      A pointer to the CPU structure for the emulated Alpha AXP 21264
 *      processor.
 *  probe:
 *      A value indicating the probe command to queue up to the probe queue.
 *  sysDc:
 *      A value indicating the controls for data movement in and out of the
 *      21264.
 *  pa:
 *      The physical address (PA) associated with the probe command.
 *  id:
 *      A value indicating the VDB or IOWB number that can be either released
 *      or probe responding can be restarted.
 *  sysData:
 *      A pointer to a buffer containing the data as a result of a read.
 *  dataLen:
 *      A value indicating the length of data in the sysData parameter.
 *  rvb:
 *      A boolean value indicating that a VDB or IOWB buffer should be freed.
 *  rpb:
 *      A boolean value indicating that a VDB's P bit should be cleared.
 *  a:
 *      A boolean value indicating that the command outstanding count should be
 *      decremented.
 *  c:
 *      A boolean value indicating that the uncommitted event counter
 *      (MB_CNTR), used for MB acknowledge, should be decremented.
 *
 * Output Parameters:
 *  None.
 *
 * Return Values:
 *  None.
 */
void AXP_21264_Add_PQ(AXP_21264_CPU *cpu,
                      int probe,
                      AXP_SYSDC sysDc,
                      u64 pa,
                      u8 id,
                      u8 *sysData,
                      bool rvb,
                      bool rpb,
                      bool a,
                      bool c)
{
    AXP_21264_CBOX_PQ *pq;

    /*
     * Before we do anything, lock the interface mutex to prevent multiple
     * accessors.
     */
    pthread_mutex_lock(&cpu->cBoxInterfaceMutex);

    /*
     * Queue up the next PQ entry.
     */
    if (cpu->pq[cpu->pqBottom].valid == true)
    {
        cpu->pqBottom = (cpu->pqBottom + 1) & 0x07;
    }
    pq = &cpu->pq[cpu->pqBottom];
    pq->probe = probe;
    pq->sysDc = sysDc;
    pq->pa = pa;
    pq->rvb = rvb;
    pq->rpb = rpb;
    pq->a = a;
    pq->c = c;

    /*
     * Determine what, if any, data is being returned to the CPU by the system.
     *
     * In HRM Table 4-4 for response type ReadDataError, the CPU action is to
     * fill the block with an all-ones reference pattern and update the tag
     * with an invalid status.
     */
    switch (sysDc)
    {
        case ReadDataError:
            memset(pq->sysData,
                   0xff,
                   (AXP_21264_DATA_SIZE * sizeof(pq->sysData)));
            break;

        case ReadData:
        case ReadDataDirty:
        case ReadDataShared:
        case ReadDataSharedDirty:
            memcpy(pq->sysData, sysData, AXP_21264_DATA_SIZE);
            break;

        default:
            break;
    }
    pq->pendingRsp = false;
    pq->valid = true;
    pq->processed = false;

    /*
     * Let the Cbox know there is something for it to process, then unlock the
     * mutex so it can.
     */
    pthread_cond_signal(&cpu->cBoxInterfaceCond);
    pthread_mutex_unlock(&cpu->cBoxInterfaceMutex);
    return;
}

/*
 * AXP_21264_Free_PQ
 *   This function is called to return a previously allocated PQ buffer.  It
 *   does this by setting the valid bit to false and adjusting the pqTop index,
 *   as necessary.
 *
 * Input Parameters:
 *   cpu:
 *       A pointer to the CPU structure for the emulated Alpha AXP 21264
 *       processor.
 *  entry:
 *      An integer value that is the entry in the PQ to be invalidated.
 *
 * Output Parameters:
 *  None.
 *
 * Return Values:
 *  None.
 */
void AXP_21264_Free_PQ(AXP_21264_CPU *cpu, u8 entry)
{
    AXP_21264_CBOX_PQ *pq = &cpu->pq[entry];
    int ii;
    int end, start1, end1, start2 = -1, end2;
    bool done = false;

    /*
     * First, clear the valid bit.
     */
    pq->valid = false;

    /*
     * We now have to see if we can adjust the top of the queue.
     */
    if (cpu->pqTop > cpu->pqBottom)
    {
        start1 = cpu->pqTop;
        end1 = AXP_21264_PQ_LEN - 1;
        start2 = 0;
        end2 = cpu->pqBottom;
    }
    else
    {
        start1 = cpu->pqTop;
        end1 = cpu->pqBottom;
    }

    /*
     * Search through the list to find the first entry that is in-use (valid).
     */
    ii = start1;
    end = end1;
    while ((ii <= end) && (done == false))
    {
        if (cpu->pq[ii].valid == false)
        {
            cpu->pqTop = (cpu->pqTop + 1) & 0x07;
        }
        else
        {
            done = true;
        }
        if ((done == false) && (start2 != -1) && (ii = end))
        {
            ii = start2;
            end = end2;
            start2 = -1;
        }
        else
        {
            ii++;
        }
    }

    /*
     * Return back to the caller.
     */
    return;
}
